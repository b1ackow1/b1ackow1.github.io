<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Rust for Linux 伪造进程名</title>
      <link href="/2026/01/03/linux-fake-process-name-for-rust/"/>
      <url>/2026/01/03/linux-fake-process-name-for-rust/</url>
      
        <content type="html"><![CDATA[<p> 这篇文章主要介绍了Rust在Linux下通过修改argv0和&#x2F;proc&#x2F;self&#x2F;comm的方式修改进程名以及原理.</p><span id="more"></span><h2 id="Begin"><a href="#Begin" class="headerlink" title="Begin"></a>Begin</h2><p>  最近在看tsh的相关代码，想着用rust重写一遍tsh,看到github上的rust以及go改写的tsh功能和体积都不如意，于是自己重新造轮子，过一遍完整的理论与项目实践。<br>  此文章示例代码都放在github上。</p><h3 id="Principle"><a href="#Principle" class="headerlink" title="Principle"></a>Principle</h3><p>  在Linux中进程名通常由修改两个地方就能伪造进程名。分别是argv[0],comm.</p><ol><li>argv[0]<br>作用:存储程序启动时的完整命令行<br>对应文件位置: &#x2F;proc&#x2F;[pid]&#x2F;cmdline<br>修改方式: 直接修改内存即可伪造进程名<br>长度: 可以很长（通常几百字节）<br>位置： 存储在进程的栈内存中</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ps aux | grep nginx</span><br><span class="line">root  1234  nginx: master process /usr/sbin/nginx -c /etc/nginx/nginx.conf</span><br><span class="line"><span class="comment">#          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</span></span><br><span class="line"><span class="comment">#          这就是 argv[0] 加上参数</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 方式2: ps -ef</span></span><br><span class="line">ps -ef | grep nginx</span><br><span class="line">root  1234  /usr/sbin/nginx -c /etc/nginx/nginx.conf</span><br></pre></td></tr></table></figure><ol start="2"><li>comm (进程任务名)<br>  长度限制: 最多16个字符(算上’\0’)<br>  位置: 存储在内核的 <code>task_struct</code> 结构体中<br>  修改方式: 使用 <code>prctl(PR_SET_NAME)</code> 系统调用<br>  对应文件: <code>/proc/[PID]/comm</code></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /proc/1234/comm</span><br><span class="line">nginx</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 方式1: ps -eo comm</span></span><br><span class="line">ps -eo pid,<span class="built_in">comm</span> | grep 1234</span><br><span class="line">1234 nginx</span><br><span class="line"><span class="comment">#    ^^^^^</span></span><br><span class="line"><span class="comment">#    这就是 comm</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 方式2: top</span></span><br><span class="line">top -p 1234</span><br><span class="line">  PID USER  COMMAND</span><br><span class="line"> 1234 root  nginx    ← 这里显示的也是 <span class="built_in">comm</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 方式3: htop</span></span><br><span class="line">htop -p 1234</span><br><span class="line">  PID COMMAND</span><br><span class="line"> 1234 nginx</span><br></pre></td></tr></table></figure><h3 id="Coding"><a href="#Coding" class="headerlink" title="Coding"></a>Coding</h3><p>根据<a href="https://github.com/orangetw/tsh/blob/master/tshd.c#L73">tinyshell</a>的源码，我们可以看到C语言版本是这么处理argv[0]修改进程名的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">memset</span>((<span class="type">void</span> *)argv[<span class="number">0</span>], <span class="string">&#x27;\0&#x27;</span>, <span class="built_in">strlen</span>(argv[<span class="number">0</span>]));</span><br><span class="line"><span class="built_in">strcpy</span>(argv[<span class="number">0</span>], FAKE_PROC_NAME);</span><br></pre></td></tr></table></figure><p>我们构造一个测试C语言程序</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;=== C语言版本 argv[0]  ===\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;原始 argv[0]: %s\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;原始长度: %lu 字节\n\n&quot;</span>, <span class="built_in">strlen</span>(argv[<span class="number">0</span>]));</span><br><span class="line">    <span class="type">char</span> *fake_name=<span class="string">&quot;fake&quot;</span>;</span><br><span class="line">    <span class="built_in">memset</span>(argv[<span class="number">0</span>],<span class="string">&#x27;\0&#x27;</span>,<span class="built_in">strlen</span>(argv[<span class="number">0</span>]));</span><br><span class="line">    <span class="built_in">strcpy</span>(argv[<span class="number">0</span>],fake_name);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;进程将运行15秒，请检查:\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  ps aux | grep %d\n&quot;</span>, getpid());</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  cat /proc/%d/cmdline | tr &#x27;\\0&#x27; &#x27; &#x27;\n&quot;</span>, getpid());</span><br><span class="line"></span><br><span class="line">    sleep(<span class="number">15</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// gcc -o test fake_name.c</span></span><br></pre></td></tr></table></figure><p>结果如下:</p><img src="/2026/01/03/linux-fake-process-name-for-rust/test_c_argv0.png" class="" title="测试结果"><p>测试OK!</p><h4 id="使用rust实现进程名修改–修改Argv-0"><a href="#使用rust实现进程名修改–修改Argv-0" class="headerlink" title="使用rust实现进程名修改–修改Argv[0]"></a>使用rust实现进程名修改–修改Argv[0]</h4><p>众所周知，<code>Rust</code>是一门内存安全的语言，不使用unsafe修改argv[0]的时候，你会发现程序内读取argv[0]是修改过的进程名，使用命令<code>ps -ef</code>之类的发现进程名还是原来的进程名。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">args</span>=std::env::<span class="title function_ invoke__">args</span>().collect::&lt;<span class="type">Vec</span>&lt;_&gt;&gt;();</span><br><span class="line">    args[<span class="number">0</span>]=<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;fake-name&quot;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;args[0]=&#123;&#125;&quot;</span>,args[<span class="number">0</span>]);</span><br><span class="line">    std::thread::<span class="title function_ invoke__">sleep</span>(std::time::Duration::<span class="title function_ invoke__">from_secs</span>(<span class="number">60</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上<code>ps -ef</code>还是显示的demo进程名</p><img src="/2026/01/03/linux-fake-process-name-for-rust/2026-01-03-12-42-47.png" class=""><p>原因是rust返回的args是一个拷贝，并不是引用，修改拷贝不影响原始数据。详情可以了解<a href="https://www.duguying.net/article/can-not-modify-argv0-in-rust">没有途径修改argv[0]</a><br>我们使用unsafe来改写上述C语言代码来实现进程名字伪造.整体逻辑如下:</p><pre><code>  定位当前程序栈地址-&gt;在栈中搜索argv[0]-&gt;计算可用空间-&gt;修改argv[0]</code></pre><ol><li>通过&#x2F;proc&#x2F;self&#x2F;maps定位到当前程序的栈地址 (因为Rust不像C那样直接暴露char **argv指针。我们必须自己找到它在内存中的位置)</li></ol><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 获取进程栈的地址范围</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// 通过读取 /proc/self/maps 查找 [stack] 区域</span></span><br><span class="line"><span class="comment">/// 返回 (stack_start, stack_end)</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">get_stack_range</span>()<span class="punctuation">-&gt;</span><span class="type">Result</span>&lt;(<span class="type">usize</span>,<span class="type">usize</span>),<span class="type">String</span>&gt;&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">maps</span>=std::fs::<span class="title function_ invoke__">read_to_string</span>(<span class="string">&quot;/proc/self/maps&quot;</span>).<span class="title function_ invoke__">map_err</span>(|e|<span class="built_in">format!</span>(<span class="string">&quot;不能读取maps:&#123;&#125;&quot;</span>,e))?;</span><br><span class="line">    <span class="keyword">let</span> (<span class="keyword">mut</span> stack_start,<span class="keyword">mut</span> stack_end)=(<span class="number">0usize</span>,<span class="number">0usize</span>);</span><br><span class="line">    <span class="comment">//查找stack行</span></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">line</span> <span class="keyword">in</span> maps.<span class="title function_ invoke__">lines</span>()&#123;</span><br><span class="line">        <span class="keyword">if</span> line.<span class="title function_ invoke__">contains</span>(<span class="string">&quot;[stack]&quot;</span>)&#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">parts</span>:<span class="type">Vec</span>&lt;&amp;<span class="type">str</span>&gt;=line.<span class="title function_ invoke__">split_whitespace</span>().<span class="title function_ invoke__">collect</span>();</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(range)=parts.<span class="title function_ invoke__">first</span>()&#123;</span><br><span class="line">                <span class="keyword">let</span> <span class="variable">addrs</span>:<span class="type">Vec</span>&lt;&amp;<span class="type">str</span>&gt;=range.<span class="title function_ invoke__">split</span>(<span class="string">&quot;-&quot;</span>).<span class="title function_ invoke__">collect</span>();</span><br><span class="line">                <span class="keyword">if</span> addrs.<span class="title function_ invoke__">len</span>()==<span class="number">2</span>&#123;</span><br><span class="line">                    stack_start=<span class="type">usize</span>::<span class="title function_ invoke__">from_str_radix</span>(addrs[<span class="number">0</span>], <span class="number">16</span>).<span class="title function_ invoke__">map_err</span>(|e|<span class="built_in">format!</span>(<span class="string">&quot;解析起始地址失败:&#123;&#125;&quot;</span>,e))?;</span><br><span class="line">                    stack_end=<span class="type">usize</span>::<span class="title function_ invoke__">from_str_radix</span>(addrs[<span class="number">1</span>], <span class="number">16</span>).<span class="title function_ invoke__">map_err</span>(|e|<span class="built_in">format!</span>(<span class="string">&quot;解析结束地址失败:&#123;&#125;&quot;</span>,e))?;</span><br><span class="line">                    <span class="keyword">return</span> <span class="title function_ invoke__">Ok</span>((stack_start,stack_end));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_ invoke__">Err</span>(<span class="string">&quot;未找到[stack]区域&quot;</span>.<span class="title function_ invoke__">to_string</span>())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单的单元测试以及结果</p><img src="/2026/01/03/linux-fake-process-name-for-rust/2026-01-04-03-13-58.png" class=""><ol start="2"><li>在栈中搜索argv[0]字符串以及地址</li></ol><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsafe</span> <span class="keyword">fn</span> <span class="title function_">find_argv0_address_in_stack</span>(_stack_start:<span class="type">usize</span>,stack_end:<span class="type">usize</span>)<span class="punctuation">-&gt;</span><span class="type">Result</span>&lt;<span class="type">usize</span>,<span class="type">String</span>&gt;&#123;  </span><br><span class="line">    <span class="keyword">let</span> <span class="variable">argv0</span>=std::env::<span class="title function_ invoke__">args</span>().<span class="title function_ invoke__">next</span>()</span><br><span class="line">    .<span class="title function_ invoke__">ok_or</span>(<span class="string">&quot;没有argv[0]&quot;</span>.<span class="title function_ invoke__">to_string</span>())?;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">argv0_bytes</span>=argv0.<span class="title function_ invoke__">as_bytes</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">search_start</span> = stack_end.<span class="title function_ invoke__">saturating_sub</span>(<span class="number">1024</span> * <span class="number">1024</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">search_end</span> = stack_end - argv0_bytes.<span class="title function_ invoke__">len</span>();</span><br><span class="line">    <span class="built_in">println!</span>(</span><br><span class="line">        <span class="string">&quot;搜索范围: 0x&#123;:x&#125; - 0x&#123;:x&#125; (&#123;&#125; 字节)&quot;</span>,</span><br><span class="line">        search_start,</span><br><span class="line">        search_end,</span><br><span class="line">        search_end - search_start</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">addr</span> <span class="keyword">in</span> (search_start..search_end).<span class="title function_ invoke__">step_by</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">ptr</span>=addr <span class="keyword">as</span> *<span class="keyword">const</span> <span class="type">u8</span>;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">matches</span> = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">0</span>..argv0_bytes.<span class="title function_ invoke__">len</span>()&#123;</span><br><span class="line">            <span class="keyword">unsafe</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> *ptr.<span class="title function_ invoke__">add</span>(i)!=argv0_bytes[i]&#123;</span><br><span class="line">                    matches=<span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">unsafe</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> matches &amp;&amp; *ptr.<span class="title function_ invoke__">add</span>(argv0_bytes.<span class="title function_ invoke__">len</span>())==<span class="number">0</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="title function_ invoke__">Ok</span>(addr);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_ invoke__">Err</span>(<span class="string">&quot;不能在栈中找到argv[0]的地址&quot;</span>.<span class="title function_ invoke__">to_string</span>())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>单元测试结果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">running 1 <span class="built_in">test</span></span><br><span class="line">搜索范围: 0x7ffdb065b000 - 0x7ffdb075afba (1048506 字节)</span><br><span class="line">找到 argv[0] 地址: 0x7ffdb0759dc8</span><br><span class="line">argv[0] 内容: /home/asd/Desktop/project/demo/target/debug/deps/demo-dc6b4fb4fd053556</span><br><span class="line"><span class="built_in">test</span> tests::test_find_argv0_address ... ok</span><br></pre></td></tr></table></figure><ol start="3"><li>计算可用空间<br>  实际上经过测试，不计算空间直接篡改argv[0]也行，但是在实战中遇到一些奇葩系统可能会出现一些奇葩问题，于是想了想还是加上，把cmdline和environ都清空，由于在栈中cmdline和environ的地址都是连续的，这样保证了伪装进程名的完整性。</li></ol><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsafe</span> <span class="keyword">fn</span> <span class="title function_">calculate_argv_space</span>(argv_start:<span class="type">usize</span>)<span class="punctuation">-&gt;</span><span class="type">Result</span>&lt;<span class="type">usize</span>,<span class="type">String</span>&gt;&#123;</span><br><span class="line">    <span class="comment">//解析cmdline和environ的长度，获取可用长度</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">cmdline</span> = std::fs::<span class="title function_ invoke__">read</span>(<span class="string">&quot;/proc/self/cmdline&quot;</span>)</span><br><span class="line">        .<span class="title function_ invoke__">map_err</span>(|e| <span class="built_in">format!</span>(<span class="string">&quot;Failed to read cmdline: &#123;&#125;&quot;</span>, e))?;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">environ_data</span> = std::fs::<span class="title function_ invoke__">read</span>(<span class="string">&quot;/proc/self/environ&quot;</span>)</span><br><span class="line">        .<span class="title function_ invoke__">map_err</span>(|e| <span class="built_in">format!</span>(<span class="string">&quot;Failed to read environ: &#123;&#125;&quot;</span>, e))?;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">argv_end</span> = argv_start + cmdline.<span class="title function_ invoke__">len</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">environ_end</span> = argv_end + environ_data.<span class="title function_ invoke__">len</span>();</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(environ_end)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>单元测试以及结果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">running 1 <span class="built_in">test</span></span><br><span class="line">搜索范围: 0x7ffcb3ce4000 - 0x7ffcb3de3fba (1048506 字节)</span><br><span class="line">argv[0] 起始地址: 0x7ffcb3de2dc6</span><br><span class="line">environ 结束地址: 0x7ffcb3de3fb1</span><br><span class="line">总可用空间: 4587 bytes (4 KB)</span><br><span class="line"><span class="built_in">test</span> tests::test_calculate_argv_space ... ok</span><br></pre></td></tr></table></figure><ol start="4"><li>修改argv[0]</li></ol><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsafe</span> <span class="keyword">fn</span> <span class="title function_">modify_argv0_name</span>(process_name:&amp;<span class="type">str</span>)<span class="punctuation">-&gt;</span><span class="type">Result</span>&lt;(),<span class="type">String</span>&gt;&#123;</span><br><span class="line">     <span class="keyword">let</span> (stack_start,stack_end)=<span class="title function_ invoke__">get_stack_range</span>()?;</span><br><span class="line">     <span class="keyword">let</span> <span class="variable">argv0_start</span> = <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        <span class="title function_ invoke__">find_argv0_address_in_stack</span>(stack_start, stack_end)?</span><br><span class="line">    &#125;;</span><br><span class="line">     <span class="keyword">let</span> <span class="variable">environ_end</span> = <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        <span class="title function_ invoke__">calculate_argv_space</span>(argv0_start)?</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">total_available</span> = environ_end - argv0_start;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">process_name_bytes</span> = process_name.<span class="title function_ invoke__">as_bytes</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查名称长度是否超过可用空间</span></span><br><span class="line">    <span class="keyword">if</span> process_name_bytes.<span class="title function_ invoke__">len</span>() + <span class="number">1</span> &gt; total_available &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_ invoke__">Err</span>(<span class="built_in">format!</span>(</span><br><span class="line">            <span class="string">&quot;进程名太长: &#123;&#125; bytes,可用空间: &#123;&#125; bytes&quot;</span>,</span><br><span class="line">            process_name_bytes.<span class="title function_ invoke__">len</span>() + <span class="number">1</span>,</span><br><span class="line">            total_available</span><br><span class="line">        ));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;修改前 argv[0]: &#123;&#125;&quot;</span>, std::env::<span class="title function_ invoke__">args</span>().<span class="title function_ invoke__">next</span>().<span class="title function_ invoke__">unwrap</span>());</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;将要修改为: &#123;&#125;&quot;</span>, process_name);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;可用空间: &#123;&#125; bytes&quot;</span>, total_available);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        std::ptr::<span class="title function_ invoke__">write_bytes</span>(argv0_start <span class="keyword">as</span> *<span class="keyword">mut</span> <span class="type">u8</span>, <span class="number">0</span>, total_available);</span><br><span class="line"></span><br><span class="line">        std::ptr::<span class="title function_ invoke__">copy_nonoverlapping</span>(</span><br><span class="line">            process_name_bytes.<span class="title function_ invoke__">as_ptr</span>(),</span><br><span class="line">            argv0_start <span class="keyword">as</span> *<span class="keyword">mut</span> <span class="type">u8</span>,</span><br><span class="line">            process_name_bytes.<span class="title function_ invoke__">len</span>()</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;修改成功！&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>单元测试以及结果</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[test]</span></span><br><span class="line">   <span class="keyword">fn</span> <span class="title function_">test_modify_argv0_name</span>()&#123;</span><br><span class="line">   </span><br><span class="line">       <span class="comment">// 修改进程名</span></span><br><span class="line">       <span class="keyword">let</span> <span class="variable">fake_name</span> = <span class="string">&quot;fakefakefakefakefakefakefakefake&quot;</span>;</span><br><span class="line">       <span class="keyword">let</span> <span class="variable">result</span> = <span class="keyword">unsafe</span> &#123; <span class="title function_ invoke__">modify_argv0_name</span>(fake_name) &#125;;</span><br><span class="line"></span><br><span class="line">       <span class="built_in">assert!</span>(result.<span class="title function_ invoke__">is_ok</span>(), <span class="string">&quot;修改进程名失败: &#123;:?&#125;&quot;</span>, result.<span class="title function_ invoke__">err</span>());</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 读取修改后的 cmdline</span></span><br><span class="line">       <span class="keyword">let</span> <span class="variable">after</span> = std::fs::<span class="title function_ invoke__">read</span>(<span class="string">&quot;/proc/self/cmdline&quot;</span>).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">       <span class="keyword">let</span> <span class="variable">after_str</span> = <span class="type">String</span>::<span class="title function_ invoke__">from_utf8_lossy</span>(&amp;after);</span><br><span class="line">       <span class="built_in">println!</span>(<span class="string">&quot;/proc/self/cmdline: &#123;:?&#125;\n&quot;</span>, after_str.<span class="title function_ invoke__">replace</span>(<span class="string">&#x27;<span class="char escape_">\0</span>&#x27;</span>, <span class="string">&quot; &quot;</span>));</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">running 1 <span class="built_in">test</span></span><br><span class="line">搜索范围: 0x7fff68427000 - 0x7fff68526fba (1048506 字节)</span><br><span class="line">修改前 argv[0]: /home/asd/Desktop/project/demo/target/debug/deps/demo-dc6b4fb4fd053556</span><br><span class="line">将要修改为: fakefakefakefakefakefakefakefake</span><br><span class="line">可用空间: 4584 bytes</span><br><span class="line">修改成功！</span><br><span class="line">/proc/self/cmdline: <span class="string">&quot;fakefakefakefakefakefakefakefake       </span></span><br></pre></td></tr></table></figure><ol start="5"><li>最终测试</li></ol><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        <span class="title function_ invoke__">modify_argv0_name</span>(<span class="string">&quot;fakenamefakenamefakenamefakenamefakenamefakenamefakenamefakename&quot;</span>).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;  cat /proc/&#123;&#125;/cmdline | tr &#x27;\\0&#x27; &#x27; &#x27;&quot;</span>, std::process::<span class="title function_ invoke__">id</span>());</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;  ps aux | grep &#123;&#125;&quot;</span>, std::process::<span class="title function_ invoke__">id</span>());</span><br><span class="line">    std::thread::<span class="title function_ invoke__">sleep</span>(std::time::Duration::<span class="title function_ invoke__">from_secs</span>(<span class="number">60</span>));</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><img src="/2026/01/03/linux-fake-process-name-for-rust/2026-01-04-04-21-38.png" class=""><p>这样就完美搞定了。</p><h4 id="使用rust实现进程名修改–修改comm"><a href="#使用rust实现进程名修改–修改comm" class="headerlink" title="使用rust实现进程名修改–修改comm"></a>使用rust实现进程名修改–修改comm</h4><p>  根据先前提到的，篡改了argv[0]后，在&#x2F;proc&#x2F;self&#x2F;comm中还是能看到原始的进程名。<br>  <img src="/2026/01/03/linux-fake-process-name-for-rust/2026-01-04-04-27-39.png" class=""><br>  那么我们使用<code>prctl</code>函数直接篡改就好了。这个函数的限制就是篡改的进程名最大长度不超过<strong>16</strong>个字符(算上’\0’)</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">//调用prctl函数修改comm</span></span><br><span class="line"><span class="keyword">unsafe</span> <span class="keyword">fn</span> <span class="title function_">mofidy_comm_name</span>(process_name:&amp;<span class="type">str</span>)<span class="punctuation">-&gt;</span><span class="type">Result</span>&lt;(), <span class="type">String</span>&gt;&#123;</span><br><span class="line">     <span class="comment">//截断长进程名到15个字符</span></span><br><span class="line">     <span class="keyword">let</span> <span class="variable">truncated_name</span>= <span class="keyword">if</span> process_name.<span class="title function_ invoke__">len</span>()&gt;<span class="number">15</span>&#123;</span><br><span class="line">        &amp;process_name[..<span class="number">15</span>]</span><br><span class="line">     &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        process_name</span><br><span class="line">     &#125;;</span><br><span class="line">     <span class="comment">//转换为C字符串</span></span><br><span class="line">     <span class="keyword">let</span> <span class="variable">c_process_name</span>=CString::<span class="title function_ invoke__">new</span>(truncated_name)</span><br><span class="line">     .<span class="title function_ invoke__">map_err</span>(|e|<span class="built_in">format!</span>(<span class="string">&quot;转换错误:&#123;&#125;&quot;</span>,e)).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用prctl</span></span><br><span class="line">    <span class="keyword">unsafe</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> libc::<span class="title function_ invoke__">prctl</span>(libc::PR_SET_NAME,c_process_name.<span class="title function_ invoke__">as_ptr</span>() <span class="keyword">as</span> <span class="type">usize</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>)&lt;<span class="number">0</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="title function_ invoke__">Err</span>(<span class="string">&quot;prctl函数调用错误&quot;</span>.<span class="title function_ invoke__">to_string</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        <span class="title function_ invoke__">modify_argv0_name</span>(<span class="string">&quot;fakenamefakenamefakenamefakenamefakenamefakenamefakenamefakename&quot;</span>).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        <span class="title function_ invoke__">mofidy_comm_name</span>(<span class="string">&quot;fakenamefakenamefakenamefakenamefakenamefakenamefakenamefakename&quot;</span>).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;  cat /proc/&#123;&#125;/cmdline | tr &#x27;\\0&#x27; &#x27; &#x27;&quot;</span>, std::process::<span class="title function_ invoke__">id</span>());</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;  cat /proc/&#123;&#125;/comm&quot;</span>, std::process::<span class="title function_ invoke__">id</span>());</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;  ps aux | grep &#123;&#125;&quot;</span>, std::process::<span class="title function_ invoke__">id</span>());</span><br><span class="line">    std::thread::<span class="title function_ invoke__">sleep</span>(std::time::Duration::<span class="title function_ invoke__">from_secs</span>(<span class="number">60</span>));</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>  效果<br>  <img src="/2026/01/03/linux-fake-process-name-for-rust/2026-01-04-04-40-53.png" class=""></p><h2 id="Ending"><a href="#Ending" class="headerlink" title="Ending"></a>Ending</h2><p>  至此就总结了常规Linux下Rust修改进程名的两种方式。已经满足了常规Linux下的需求了，如果是freebsd以及sunos之类的，那么就需要把ptrcl函数得更换一下了。</p>]]></content>
      
      
      <categories>
          
          <category> Programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> argv0 </tag>
            
            <tag> tinyshell </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
